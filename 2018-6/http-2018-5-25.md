从浏览器输入URL会发生什么?从浏览器控制台了解http协议
=========
## 第一篇.简单的http请求

---

本文属于本人学习计算机网络这本书的一个总结和实验,并不会特意追求文字的通俗性,只是作为学习的一个简单备份和总结.

---

### 为什么是浏览器控制台?
因为浏览器控制台作为实验的载体最为直观,只需要打开浏览器时候按住f12就可以出现.而且chrome的浏览器控制台的network选项中拥有有足够多的信息,足够作为对于网络的一个重要补充.作为PHP程序员也能够有效利用浏览器了解网络的知识.

![avatar](2018-4-15/network.png)

### http协议
作为系列的第一篇,估计也会是唯一一篇,本片的重点将购置在应用层的http协议上面,其他诸如网络层的IP.传输层的TCP协议只会粗粗讲过,并不会深入,如果有时间会在其他文章里面提到.


### url
你在chrome的地址栏输入一个地址,在某些文章里面可能会提到,诸如操作系统级别在键盘缓冲区啊诸如此类的东西,当然本文的重点并不在这里,我们只会讨论网络这一个层级,尤其是在在应用层的http这一个级别.
所以我们首先讨论在地址栏输入的地址,也就是url.
url,全称是Uniform Resource Locators.翻译成中文就是统一资源定位符.通俗的讲就是万维网的通用地址,用于表示某个页面或者资源在网络中的位置.
url在1994被Tim Berners-Lee提出,用来解决在网络中定义和访问页面.官方文档是[rfc1738](.https://tools.ietf.org/html/rfc1738)顺便一提http1.0版本是rfc1945

url的通用语法如下

scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]


- scheme<br>
即协议,通常在浏览器上面就是http协议,当然还有这两年已经开始逐渐普及开来的https协议,以及逐渐被网盘取代,已经比较少见的ftp协议;除此之外,在还有在浏览器上面直接访问本地HTML页面是否会出现file协议,浏览器自带的about配置.等等不一而足

- user和password<br>
这两个属于可选项,我个人在FTP里面讲过这两个可选项,不过通常http协议都会用其他的登录机制来处理登录也就不会放在URL里面直接明文登录

- host<BR>主机名或者IP

- query<BR>查询参数,通常情况在服务器那边看到的是GET方法获取到的参数
- fragment
<br>锚点这个我个人不熟,不过貌似前端可以用来定位当前打开的地址,浏览器可以用它定位滚动到页面下的哪一个位置.

### DNS
,如果我们在URL里面的host这里是主机名,我们这输入URL之后操作会开始进入DNS解析
- 在浏览器DNS缓存中搜索
- 在操作系统DNS缓存中搜索
- 读取系统hosts文件，查找其中是否有对应的ip
- 向本地配置的首选DNS服务器发起域名解析请求
解析什么
在这里浏览器会开始系统调用操作,当然我们这里并不会详细谈论DNS的内容,总之,从DNS之后我们获取到了IP,就可以被上层协议(传输层的TCP协议使用)

***

在这里我打开标示或者批注:作为TCP协议我们必须明白一点,TCP协议本子上是进程通信,而不是服务器与客户端的通信.通常而言也就是socket编程,我们会使用端口进行通信,使用端口加IP进行编程,计算机网络的课后习题里面讨论了为什么使用端口而不是直接使用IP地址来进行通信,这一点可以延展开来

---


### TCP

现在我们开始一个最简单的请求,因为我的本地的Linux环境下,所以就在根目录下新建一个html文件,并且自编写最简单的页面数据.
当然你也可以使用wamp或者其他的集成环境.
我们在浏览器里面输入127.0.0.1/test.html
![avatar](2018-4-15/TCP.png)
这里我们需要了解一点,默认的浏览器会默认补全URL的协议前缀,你可以看到右下角的request url 这里已经添加了http前缀
这里我们要重点强调一点,就是对于每一次http请求而言,在传输层上面都是完整的TCP请求,都实现了三次握手,二次挥手.并且我们上面提到了,由于是进程之间通过socket通信,并且是双工通信,即客户端也就是我们浏览器的进程,发起请求,服务器端响应,并且在建立连接之后,发出响应,之后关闭TCP.
![avatar](2018-4-15/http.png)
在上面的图片我们看到general即普通模块,response headers 即服务器给我们的响应头 , request headers ,客户端的请求头.
标签栏里面了response 即服务器实际的响应.

当然这些都会在未来的文章里面解释,我们现在关注实际HTTP发生的时候具体发生了什么,也就是在最简单的HTTP请求是如何在TCP上面完成数据传输
.


### 客户端

我们上面提到了浏览器通过缓存系统调用等种种手段获取了服务器IP地址,这里我们由于使用了127.0.0.1直接用了默认本地地址IP,也就忽略了DNS这个步骤了.
我们在图片的上角,remote address:127.0.0.1:80
- 浏览器会尝试和128.0.0.1也就是本地的80端口建立TCP连接
- 浏览器发送HTTP报文,请求test.所以就在根目录下新建一个html文件
- 服务器发送响应,发出页面
- 浏览器显示页面,通常这里会使用DOM树之类的前段方法渲染页面,当然这里不属于我们讨论的范围.
- 如果短期内没有请求,我们就关闭页面

### 服务器端

在这里我们默认读者已经了解TCP协议,对于传输层有不错的了解.
我们知道服务器的守护进程会监听特定端口,这里http协议的默认端口是80端口,在http请求发生后,通常情况,守护进程会复制一个子进程出来,处理这个请求.这也是传统的网络服务器干的事情.
当然在现代的服务器会干的更多,诸如使用前端模块监听,后端多个线程模块处理,更或者利用fastcgi协议下,使用多个其他应用程序线程处理.甚至是引入方向代理,将请求导向其他服务器不一而足.
当然我们在这里不会多讨论更多东西
我们只需要了解之后发生的事情
- 接受TCP请求
- 获取页面的路径
- 获取文件
- 将文件内容发送给客户端
- 释放TCP请求

这就是HTTP协议下最简单的一个连接,在客户端和服务器之间发生的事情.
当然我们既然讨论现代服务器我们可以吧第三部和第四部更为扩展话
- 解析被请求的web页
- 执行对与页面的权限控制,在Apache里面就是著名和常用htacess文件
- 检查缓存(服务器级别)
- 从磁盘上请求页面或者运行一个创建页面的程序(PHP JSP PYTHON)
- 响应页面的其他部分(js请求,MIME类型)
- 响应返回给客户端
- 记录日志
